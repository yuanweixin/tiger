pub mod x86_64;

use crate::{
    frame::FrameRef,
    ir::{IrExp, IrStm},
    temp::{self, Uuids},
};

use std::str::FromStr;

#[derive(Debug)]
pub struct Src(Vec<temp::Temp>);
#[derive(Debug)]
pub struct Dst(Vec<temp::Temp>);

impl Dst {
    fn empty() -> Self {
        Dst(vec![])
    }
}

impl Src {
    fn empty() -> Self {
        Src(vec![])
    }
}

#[derive(Debug)]
pub enum Instr {
    Oper {
        // template for the final assembly generation.
        // target specific implementations are expected to have some custom placeholders
        // in the template, for the src, dst registers, relevant jump labels. other placeholders
        // referring to other data can be used in tandem with the aux data.
        assem: &'static str,
        // basically all the registers that gets "trashed" by the assembly.
        // for example, mul on x86 would affect EAX,EDX, so those need to be listed.
        dst: Dst,
        // this needs to list all the "dependency" registers.
        // for instance, a CALL might have its arguments translated into temp's.
        // even though those temp's would not appear in the assembly string, they
        // need to be included in source, as input for relevant backend stages.w
        src: Src,
        jump: Vec<temp::Label>,
    },
    Label {
        assem: &'static str,
        lab: temp::Label,
    },
    Move {
        assem: &'static str,
        dst: temp::Temp,
        src: temp::Temp,
    },
}

pub trait Codegen {
    /// Given an IrStm, emits the abstract assembly for it.
    fn munch_stm(stm: IrStm, result: &mut Vec<Instr>, gen: &mut dyn Uuids);

    /// Given the IrExp, outputs the abstract register that holds the value.
    fn munch_exp(exp: IrExp, result: &mut Vec<Instr>, gen: &mut dyn Uuids) -> temp::Temp;

    /// The entry point for translating into.
    /// The frame argument is only used if we attempt to eliminate the frame pointer.
    /// This is described on p206 of Appel.
    /// Roughly, a label is generated to hold the frame size of the function represented by the frame.
    /// The frame would be queried for the value of that label. For example, let sp be stack pointer,
    /// L14_framesize be the location of that constant. Then, to allocate the frame, we do sp+L14_framesize.
    /// The L14_framesize is expected to be generated by the prologue of the frame (frame::proc_entry_exit3).
    fn code_gen_frame(f: FrameRef, stm: IrStm, instrs: &mut Vec<Instr>, gen: &mut dyn Uuids);

    // need this because we model the to-be-generated-code in units of "fragments"
    // and string happens to be one type of fragment. the frame-related translation
    // doesn't apply to strings.
    fn code_gen_string(s: String, l: temp::Label, instrs: &mut Vec<Instr>);
}

impl Instr {
    pub fn fmt(&self, tm: temp::TempMap, relaxed: bool, gen: &mut dyn Uuids) -> String {
        let mut res = String::new();

        match self {
            Instr::Oper {
                assem,
                dst,
                src,
                jump,
            } => {
                let mut tmp = String::new();
                let mut iter = assem.char_indices().peekable();
                while let Some((_, c)) = iter.peek() {
                    match c {
                        '\'' => {
                            iter.next(); // consume the '
                            let kind = iter.next();
                            if kind.is_none() {
                                panic!("impl bug: invalid asm template string {}", assem);
                            }
                            tmp.clear();
                            while let Some((_, d)) = iter.peek() {
                                tmp.push(*d);
                                iter.next(); // consume
                            }

                            let template_arg_idx = match usize::from_str(tmp.as_str()) {
                                Ok(template_arg_idx) => template_arg_idx,
                                Err(..) => {
                                    panic!("impl bug: invalid asm template string {}", assem)
                                }
                            };

                            let (_, kind_char) = kind.unwrap();
                            match kind_char {
                                'S' | 's' => {
                                    if template_arg_idx >= src.0.len() {
                                        panic!("impl bug: invalid index {} in asm template string referencing src'{}'", template_arg_idx, assem);
                                    }
                                    let t = src.0[template_arg_idx];
                                    if let Some(s) = tm.get(&t) {
                                        res.push_str(s);
                                    } else {
                                        if relaxed {
                                            res.push_str(t.to_string().as_str());
                                        } else {
                                            panic!("impl bug: unable to find a register assignment for temp {}", t.to_string());
                                        }
                                    }
                                }
                                'J' | 'j' => {
                                    if template_arg_idx >= jump.len() {
                                        panic!("impl bug: invalid index {} in asm template string referencing jump'{}'", template_arg_idx, assem);
                                    }
                                    let t = jump[template_arg_idx];
                                    match t {
                                        temp::Label::Unnamed(id) => {
                                            res.push_str(format!(".L{}", id).as_str());
                                        }
                                        temp::Label::Named(sym) => {
                                            if let Some(s) = gen.resolve(&sym) {
                                                res.push_str(s);
                                            } else {
                                                panic!("impl bug: named label cannot be resolved to a string");
                                            }
                                        }
                                    }
                                }
                                'D' | 'd' => {
                                    if template_arg_idx >= dst.0.len() {
                                        panic!("impl bug: invalid index {} in asm template string referencing dst'{}'", template_arg_idx, assem);
                                    }
                                    let t = dst.0[template_arg_idx];
                                    if let Some(s) = tm.get(&t) {
                                        res.push_str(s);
                                    } else {
                                        if relaxed {
                                            res.push_str(t.to_string().as_str());
                                        } else {
                                            panic!("impl bug: unable to find a register assignment for temp {}", t.to_string());
                                        }
                                    }
                                }
                                x => panic!(
                                    "impl bug: invalid control char {} in asm template {}",
                                    x, assem
                                ),
                            }
                        }
                        some_char => {
                            res.push(*some_char);
                            iter.next(); // consume
                        }
                    }
                }
            }
            Instr::Label { assem, lab } => {
                let mut iter = assem.char_indices().peekable();
                while let Some((_, c)) = iter.peek() {
                    match c {
                        '\'' => {
                            iter.next(); // consume the '
                                         // insert the label.
                            match lab {
                                temp::Label::Unnamed(id) => {
                                    res.push_str(format!("{}", id).as_str());
                                }
                                temp::Label::Named(sym) => {
                                    let s = gen.resolve(sym);
                                    if s.is_none() {
                                        panic!(
                                            "impl bug: named label cannot be resolved to a string"
                                        );
                                    }
                                    res.push_str(s.unwrap());
                                }
                            }
                        }
                        some_char => {
                            res.push(*some_char);
                            iter.next(); // consume
                        }
                    }
                }
            }
            Instr::Move { assem, dst, src } => {
                let mut iter = assem.char_indices().peekable();
                while let Some((_, c)) = iter.peek() {
                    match c {
                        '\'' => {
                            iter.next(); // consume the '
                            let kind = iter.next();
                            if kind.is_none() {
                                panic!("impl bug: invalid asm template string {}", assem);
                            }

                            let (_, kind_char) = kind.unwrap();
                            match kind_char {
                                'S' | 's' => {
                                    if let Some(s) = tm.get(src) {
                                        res.push_str(s);
                                    } else {
                                        if relaxed {
                                            res.push_str(src.to_string().as_str());
                                        } else {
                                            panic!("impl bug: unable to find a register assignment for temp {}", src.to_string());
                                        }
                                    }
                                }
                                'D' | 'd' => {
                                    if let Some(s) = tm.get(dst) {
                                        res.push_str(s);
                                    } else {
                                        if relaxed {
                                            res.push_str(dst.to_string().as_str());
                                        } else {
                                            panic!("impl bug: unable to find a register assignment for temp {}", dst.to_string());
                                        }
                                    }
                                }
                                x => panic!(
                                    "impl bug: invalid control char {} in asm template {}",
                                    x, assem
                                ),
                            }
                        }
                        some_char => {
                            res.push(*some_char);
                            iter.next(); // consume
                        }
                    }
                }
            }
        }
        res
    }
}
